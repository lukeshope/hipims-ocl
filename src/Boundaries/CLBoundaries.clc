/*
 * ------------------------------------------
 *
 *  HIGH-PERFORMANCE INTEGRATED MODELLING SYSTEM (HiPIMS)
 *  Luke S. Smith and Qiuhua Liang
 *  luke@smith.ac
 *
 *  School of Civil Engineering & Geosciences
 *  Newcastle University
 * 
 * ------------------------------------------
 *  This code is licensed under GPLv3. See LICENCE
 *  for more information.
 * ------------------------------------------
 *  BOUNDARY CONDITIONS
 * ------------------------------------------
 *  Management functions for a domain
 *  boundaries.
 * ------------------------------------------
 *
 */

__kernel void bdy_Cell (
	__constant		sBdyCellConfiguration *		pConfiguration,
	__global		cl_ulong const * restrict	pRelations,
	__global		cl_double4 const * restrict pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	__private cl_long				lRelationID		= get_global_id(0);
	__private sBdyCellConfiguration pConfig			= *pConfiguration;
	__private cl_double				dLocalTime		= *pTime;
	__private cl_double				dLocalTimestep  = *pTimestep;

	if (lRelationID >= pConfig.RelationCount || dLocalTime >= pConfig.TimeseriesLength || dLocalTimestep <= 0.0)
		return;

	__private cl_ulong				ulBaseTimestep  = (cl_ulong)floor( dLocalTime / pConfig.TimeseriesInterval );
	__private cl_ulong				ulNextTimestep  = ulBaseTimestep + 1;
	__private cl_ulong				ulCellID		= pRelations[lRelationID];
	__private cl_double4			pCellData		= pCellState[ulCellID];
	__private cl_double				dCellBed		= pCellBed[ulCellID];
	__private cl_double4			pTSBase			= pTimeseries[ulBaseTimestep];
	__private cl_double4			pTSNext			= pTimeseries[ulNextTimestep];

	// Interpolate between timesteps
	__private cl_double4			pTSInterp = pTSBase + (pTSNext - pTSBase) * ( fmod(dLocalTime, pConfig.TimeseriesInterval ) / pConfig.TimeseriesInterval);

	// Apply depth/fsl
	if (pConfig.DefinitionDepth == BOUNDARY_DEPTH_IS_DEPTH)
	{
		#ifdef DEBUG_OUTPUT
		printf("Depth is fixed.\n");
		#endif
		pCellData.x = dCellBed + pTSInterp.y;			// Depth is fixed
	}
	else if (pConfig.DefinitionDepth == BOUNDARY_DEPTH_IS_FSL)
	{
		#ifdef DEBUG_OUTPUT
		printf("FSL is fixed.\n");
		#endif
		pCellData.x = fmax(dCellBed, pTSInterp.y);		// FSL is fixed
	}
	else
	{
		#ifdef DEBUG_OUTPUT
		printf("Depth and FSL are free.\n");
		#endif
		if (fabs(pTSInterp.z) > VERY_SMALL ||
			fabs(pTSInterp.w) > VERY_SMALL ||
			pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VOLUME)
		{
			// Calculate a suitable depth based
			__private cl_double dDepth = (fabs(pTSInterp.z) * dLocalTimestep) / DOMAIN_DELTAY + (fabs(pTSInterp.w) * dLocalTimestep) / DOMAIN_DELTAX;
			__private cl_double dNormalDepth = fmax(pown(pTSInterp.z, 2) / GRAVITY, pown(pTSInterp.w, 2) / GRAVITY);
			__private cl_double dCriticalDepth = fmax(pow(pow(pTSInterp.z, 2) / GRAVITY, 1.0 / 3.0), pow(pow(pTSInterp.w, 2) / GRAVITY, 1.0 / 3.0));

			// Not going to impose a direction if we're trying to represent
			// a surging discharge rate (e.g. manhole surge)
			if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VOLUME)
			{
				// In the case of volume boundaries, no scaling has taken place
				dNormalDepth = 0.0;
				if (pTSInterp.z < 0.0) {
					dDepth = -(fabs(pTSInterp.z) * dLocalTimestep) / (DOMAIN_DELTAX * DOMAIN_DELTAY);
				} else {
					dDepth = (fabs(pTSInterp.z) * dLocalTimestep) / (DOMAIN_DELTAX * DOMAIN_DELTAY);
				}
				dCriticalDepth = 0.0;
				pTSInterp.z = 0.0;
				pTSInterp.w = 0.0;
			}
			
			pCellData.x = fmax(dCellBed + dCriticalDepth, pCellData.x + dDepth);
			
			#ifdef DEBUG_OUTPUT
			printf("Setting depth as %f.\n", dDepth);
			#endif
		}
	}

	if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_DISCHARGE)
	{
		// Apply flow in X direction
		pCellData.z = pTSInterp.z;
	}
	else if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VELOCITY) {
		// Apply velocity in X direction
		pCellData.z = pTSInterp.z * (pCellData.x - dCellBed);
	}

	if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_DISCHARGE)
	{
		// Apply flow in Y direction
		pCellData.w = pTSInterp.w;
	}
	else if (pConfig.DefinitionDischarge == BOUNDARY_DISCHARGE_IS_VELOCITY) {
		// Apply velocity in X direction
		pCellData.w = pTSInterp.w * (pCellData.x - dCellBed);
	}

	#ifdef DEBUG_OUTPUT
	printf("Final Cell Data:       { %f, %f, %f, %f }\n", pCellData.x, pCellData.y, pCellData.z, pCellData.w);
	#endif

	pCellState[ ulCellID ] = pCellData;
}

__kernel void bdy_Uniform(
	__constant		sBdyUniformConfiguration *	pConfiguration,
	__global		cl_double2 const * restrict	pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	// Which global series are we processing, and which cell
	// Global ID is X, Y cell, then Z for the series
	__private cl_long		lIdxX = get_global_id(0);
	__private cl_long		lIdxY = get_global_id(1);
	__private cl_ulong		ulIdx;

	// Don't bother if we've gone beyond the domain bounds
	if (lIdxX >= DOMAIN_COLS - 1 ||
		lIdxY >= DOMAIN_ROWS - 1 ||
		lIdxX <= 0 ||
		lIdxY <= 0)
		return;

	ulIdx = getCellID(lIdxX, lIdxY);

	// How far in to the simulation are we? And current cell data
	__private sBdyUniformConfiguration	pConfig			= *pConfiguration;
	__private cl_double4				pCellData		= pCellState[ulIdx];
	__private cl_double					dCellBedElev	= pCellBed[ulIdx];
	__private cl_double					dLclTime		= *pTime;
	__private cl_double					dLclRealTimestep= *pTimestep;
	__private cl_double					dLclTimestep	= *pTimeHydrological;

	// Hydrological processes have their own timesteps
	if (dLclTimestep < TIMESTEP_HYDROLOGICAL || dLclRealTimestep <= 0.0)
		return;

	if ( dLclTime >= pConfig.TimeseriesLength || pCellData.y <= -9999.0 )
		return;

	// Calculate the right cell and stuff to be grabbing data from here...
	__private cl_ulong ulTimestep = (cl_ulong)floor(dLclTime / pConfig.TimeseriesInterval);
	__private cl_double2 dRecord = pTimeseries[ulTimestep];

	// Apply the value...
	if (pConfig.Definition == BOUNDARY_UNIFORM_RAIN_INTENSITY)
		pCellData.x += dRecord.y / 3600000.0 * dLclTimestep;

	if (pConfig.Definition == BOUNDARY_UNIFORM_LOSS_RATE)
		pCellData.x = max(dCellBedElev, pCellData.x - dRecord.y / 3600000.0 * dLclTimestep);

	// Return to global memory
	pCellState[ulIdx] = pCellData;
}

__kernel void bdy_Gridded (
	__constant		sBdyGriddedConfiguration *	pConfiguration,
	__global		cl_double const * restrict	pTimeseries,
	__global		cl_double *					pTime,
	__global		cl_double *					pTimestep,
	__global		cl_double *					pTimeHydrological,
	__global		cl_double4 *				pCellState,
	__global		cl_double *					pCellBed,
	__global		cl_double *					pCellManning
	)
{
	// Which global series are we processing, and which cell
	// Global ID is X, Y cell, then Z for the series
	__private cl_long		lIdxX = get_global_id(0);
	__private cl_long		lIdxY = get_global_id(1);
	__private cl_ulong		ulIdx;

	// Don't bother if we've gone beyond the domain bounds
	if (lIdxX >= DOMAIN_COLS - 1 ||
		lIdxY >= DOMAIN_ROWS - 1 ||
		lIdxX <= 0 ||
		lIdxY <= 0 )
		return;

	ulIdx = getCellID(lIdxX, lIdxY);

	// How far in to the simulation are we? And current cell data
	__private sBdyGriddedConfiguration	pConfig			= *pConfiguration;
	__private cl_double4				pCellData		= pCellState[ulIdx];
	__private cl_double					dCellBedElev	= pCellBed[ulIdx];
	__private cl_double					dLclTime		= *pTime;
	__private cl_double					dLclTimestep	= *pTimeHydrological;

	// Cell disabled?
	if (pCellData.y <= -9999.0 || pCellData.x == -9999.0)
		return;

	// Hydrological processes have their own timesteps
	if (dLclTimestep < TIMESTEP_HYDROLOGICAL)
		return;

	// Calculate the right cell and stuff to be grabbing data from here...
	__private cl_ulong ulTimestep = (cl_ulong)floor( dLclTime / pConfig.TimeseriesInterval );
	if ( ulTimestep >= pConfig.TimeseriesEntries ) ulTimestep = pConfig.TimeseriesEntries;

	__private cl_double ulColumn  = floor( ( ( (cl_double)lIdxX * (cl_double)DOMAIN_DELTAX ) - pConfig.GridOffsetX ) / pConfig.GridResolution );
	__private cl_double ulRow     = floor( ( ( (cl_double)lIdxY * (cl_double)DOMAIN_DELTAY ) - pConfig.GridOffsetY ) / pConfig.GridResolution );
	__private cl_ulong ulBdyCell  = ( pConfig.GridRows * pConfig.GridCols ) * ulTimestep +
									( pConfig.GridCols * (cl_ulong)ulRow ) + (cl_ulong)ulColumn;
	__private cl_double dRate	  = pTimeseries[ ulBdyCell ];

	// Apply the value...
	if ( pConfig.Definition == BOUNDARY_GRIDDED_RAIN_INTENSITY )
		pCellData.x += dRate / 3600000.0 * dLclTimestep;

	if ( pConfig.Definition == BOUNDARY_GRIDDED_MASS_FLUX )
		pCellData.x += dRate / ( (cl_double)DOMAIN_DELTAX * (cl_double)DOMAIN_DELTAY ) * dLclTimestep;

	// Return to global memory
	pCellState[ulIdx] = pCellData;
}

__kernel void bdy_SimplePipe (
	__constant		sBndySPipeConfiguration *		pConfiguration,
	__global		cl_double *						pTime,
	__global		cl_double *						pTimestep,
	__global		cl_double *						pTimeHydrological,
	__global		cl_double4 *					pCellState,
	__global		cl_double *						pCellBed,
	__global		cl_double *						pCellManning
	)
{
	__private sBndySPipeConfiguration	pConfig			= *pConfiguration;
	__private cl_double					dLocalTime		= *pTime;
	__private cl_double					dLocalTimestep  = *pTimestep;
	
	if (dLocalTimestep <= 0.0)
		return;

	__private cl_ulong					ulIdxStart		= getCellID(pConfig.uiStartCellX, pConfig.uiStartCellY);
	__private cl_ulong					ulIdxEnd		= getCellID(pConfig.uiEndCellX, pConfig.uiEndCellY);
	__private cl_double4				pStartData		= pCellState[ulIdxStart];
	__private cl_double					dStartBed		= pCellBed[ulIdxStart];
	__private cl_double4				pEndData		= pCellState[ulIdxEnd];
	__private cl_double					dEndBed			= pCellBed[ulIdxEnd];

	__private cl_double					dStartVelocityX = pStartData.z / max(VERY_SMALL, pStartData.x - dStartBed);
	__private cl_double					dStartVelocityY = pStartData.w / max(VERY_SMALL, pStartData.x - dStartBed);
	__private cl_double					dEndVelocityX   = pEndData.z / max(VERY_SMALL, pEndData.x - dEndBed);
	__private cl_double					dEndVelocityY   = pEndData.w / max(VERY_SMALL, pEndData.x - dEndBed);
	__private cl_double					dPipeDischarge	= 0.0;

	#ifdef DEBUG_OUTPUT
	printf("-- SIMPLE PIPE BOUNDARY --\n");
	printf(" Configuration:\n");
	printf("   Start cell:        %u, %u\n", pConfig.uiStartCellX, pConfig.uiStartCellY);
	printf("   Start invert:      %f m\n", pConfig.invertStart);
	printf("   Start bed:         %f m\n", dStartBed);
	printf("   End cell:          %u, %u\n", pConfig.uiEndCellX, pConfig.uiEndCellY);
	printf("   End invert:        %f m\n", pConfig.invertEnd);
	printf("   End bed:           %f m\n", dEndBed);
	printf("   Roughness:         %f mm\n", pConfig.roughness);
	printf("   Length:            %f m\n", pConfig.length);
	printf("   Loss coefficients: %f\n", pConfig.lossCoefficients);
	printf("   Diameter:          %f m\n", pConfig.diameter);
	printf(" Initial states:\n");
	printf("   Start of pipe:\n");
	printf("     Water level:     %f m\n", max(dStartBed, pStartData.x));
	printf("     Pipe depth:      %f m\n", max(dStartBed, pStartData.x) - pConfig.invertStart);
	printf("     UW discharge X:  %f m^2/s (%f m/s)\n", pStartData.z, dStartVelocityX);
	printf("     UW discharge Y:  %f m^2/s (%f m/s)\n", pStartData.w, dStartVelocityY);
	printf("   End of pipe:\n");
	printf("     Water level:     %f m\n", max(dEndBed, pEndData.x));
	printf("     Pipe depth:      %f m\n", max(dEndBed, pEndData.x) - pConfig.invertEnd);
	printf("     UW discharge X:  %f m^2/s (%f m/s)\n", pEndData.z, dEndVelocityX);
	printf("     UW discharge Y:  %f m^2/s (%f m/s)\n", pEndData.w, dEndVelocityY);
	#endif

	if (pStartData.x - pConfig.invertStart < VERY_SMALL || pConfig.invertStart < dStartBed) {
		#ifdef DEBUG_OUTPUT
		printf("  Pipe is empty or close. No discharge.\n");
		if (pConfig.invertStart < dStartBed) {
			printf("  [WARNING] Pipe invert is below bed level of cell.\n");
		}
		#endif
		return;
	}

	// Shape factor calculations to be used in the case of partially full pipes
	__private cl_double		dProportionalDepthAngle		= PI * 2.0;
	__private cl_double		dPartialShapeFactor			= 1.0;

	if ((pStartData.x - pConfig.invertStart) < pConfig.diameter) {
		dProportionalDepthAngle = 2 * acos(1.0 - (2 * (pStartData.x - pConfig.invertStart)) / pConfig.diameter);
		if (dProportionalDepthAngle > 0.0) {
			dPartialShapeFactor = (dProportionalDepthAngle - sin(dProportionalDepthAngle)) / dProportionalDepthAngle;
		}
	}

	#ifdef DEBUG_OUTPUT
	printf(" Partial pipe flow factors:\n");
	printf("   Prop depth angle:  %f\n", dProportionalDepthAngle);
	printf("   Shape factor:      %f\n", dPartialShapeFactor);
	#endif

	__private cl_double		dFrictionHeadLossEst;
	__private cl_double		dVelocity;
	__private cl_double		dOtherHeadTerms;
	__private cl_double		dError = 9999999999.9;
	__private cl_double		dInitialFrictionHeadLoss = (pStartData.x - pConfig.invertStart) > 0.0 
		? (pConfig.invertStart + ((max(pConfig.invertStart, pStartData.x) - pConfig.invertStart) / 2.0)) - (pConfig.invertEnd + ((max(pConfig.invertEnd, pEndData.x) - pConfig.invertEnd) / 2.0)) 
		: 0.0;
	__private cl_uint		uiIterations = 0;

	if (dInitialFrictionHeadLoss <= 0.0) {
		return;
	}

	// Iterative process for Darcy-Weisbach
	while (uiIterations < 500 && fabs(dError) > 0.0001) {
		uiIterations				+= 1;

		// Apply a number of methods to come up with sensible friction head losses
		// as the value MUST be positive. In situations where other losses far exceed
		// the friction losses, this could still fail in which case expect NaN terminations.
		double dLastFrictionHeadLoss = dFrictionHeadLossEst;
		if (uiIterations <= 1) {
			dFrictionHeadLossEst		= dInitialFrictionHeadLoss;
		} else {
			if (dFrictionHeadLossEst > dOtherHeadTerms) {
				dFrictionHeadLossEst = dFrictionHeadLossEst - dOtherHeadTerms;
			} else {
				double dMultiplier = fabs(dError) < 0.2 ? 0.002 : 0.2;
				double dSign	   = sign(dError);
				dFrictionHeadLossEst = dFrictionHeadLossEst
					+ dSign
					* max(
						(cl_double)(min(fabs(dError), dFrictionHeadLossEst) * dMultiplier),
						(cl_double)0.00001
					);
			}
		}

		if (dFrictionHeadLossEst < 0.0) {
			dFrictionHeadLossEst = dLastFrictionHeadLoss * 2.0 / 3.0;
		}

		dVelocity					= -2.0
			* sqrt(2.0 * GRAVITY * dPartialShapeFactor * pConfig.diameter * dFrictionHeadLossEst / pConfig.length)
			* log10(
				 ( (pConfig.roughness / 1000.0) / (3.7 * dPartialShapeFactor * pConfig.diameter) )
			   + ( (2.51 * 1.13e-6) / ( (dPartialShapeFactor * pConfig.diameter) * sqrt(2.0 * GRAVITY * dPartialShapeFactor * pConfig.diameter * dFrictionHeadLossEst / pConfig.length) ))
			  );
		dOtherHeadTerms = pConfig.lossCoefficients * (dVelocity * dVelocity / (2.0 * GRAVITY));
		dError = dInitialFrictionHeadLoss - dFrictionHeadLossEst - dOtherHeadTerms;

		#ifdef DEBUG_OUTPUT
		printf(" Results of iteration:\n");
		printf("   Friction loss: %f\n", dFrictionHeadLossEst);
		printf("   Velocity:      %f\n", dVelocity);
		printf("   Other head:    %f\n", dOtherHeadTerms);
		printf("   Error:         %f\n", dError);
		#endif
	}

	if (uiIterations >= 500 || fabs(dError) > 0.0001) {
		// Force NaN to terminate simulation
		dPipeDischarge = sqrt(-1.0);
	}

	dPipeDischarge = dVelocity * PI * (dPartialShapeFactor * pConfig.diameter / 2.0) * (dPartialShapeFactor * pConfig.diameter / 2.0);

	#ifdef DEBUG_OUTPUT
	printf(" %u iterations, with error %f.\n", uiIterations, dError);
	printf(" Pipe flow:\n");
	printf("   Velocity:          %f\n", dVelocity);
	printf("   Discharge:         %f\n", dPipeDischarge);
	#endif

	// Lower the level upstream, increase the level downstream
	if (pEndData.x < dEndBed + VERY_SMALL) {
		pEndData.z = 0.0;
		pEndData.w = 0.0;
	}

	pStartData.x = max(dStartBed, pStartData.x - (dPipeDischarge * dLocalTimestep) / DOMAIN_DELTAX / DOMAIN_DELTAY);
	pEndData.x = max(dEndBed, pEndData.x) + (dPipeDischarge * dLocalTimestep) / DOMAIN_DELTAX / DOMAIN_DELTAY;

	if (pStartData.x < dStartBed + VERY_SMALL) {
		pStartData.z = 0.0;
		pStartData.w = 0.0;
	}

	// IMPORTANT NOTE
	// The velocity within the pipe is not used to adjust velocities in the cells neighbouring
	// the entry or exit of the pipe. This could be a future development.

	#ifdef DEBUG_OUTPUT
	printf(" Final states:\n");
	printf("   Volume changes:\n");
	printf("     Time:            %f s\n", dLocalTime);
	printf("     Timestep:        %f s\n", dLocalTimestep);
	printf("     Volume:          %f m3\n", dPipeDischarge * dLocalTimestep);
	printf("     Level change:    %f m\n", (dPipeDischarge * dLocalTimestep) / DOMAIN_DELTAX / DOMAIN_DELTAY);
	printf("   Start of pipe:\n");
	printf("     Water level:     %f m\n", pStartData.x);
	printf("     Depth:           %f m\n", pStartData.x - dStartBed);
	printf("     UW discharge X:  %f m^2/s (%f m/s)\n", pStartData.z, dStartVelocityX);
	printf("     UW discharge Y:  %f m^2/s (%f m/s)\n", pStartData.w, dStartVelocityY);
	printf("   End of pipe:\n");
	printf("     Water level:     %f m\n", pEndData.x);
	printf("     Depth:           %f m\n", pEndData.x - dEndBed);
	printf("     UW discharge X:  %f m^2/s (%f m/s)\n", pEndData.z, dEndVelocityX);
	printf("     UW discharge Y:  %f m^2/s (%f m/s)\n", pEndData.w, dEndVelocityY);
	#endif

	pCellState[ulIdxStart] = pStartData;
	pCellState[ulIdxEnd] = pEndData;
}
